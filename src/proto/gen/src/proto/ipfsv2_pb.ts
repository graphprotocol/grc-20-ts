// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file src/proto/ipfsv2.proto (package ipfsv2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum ipfsv2.ActionType
 */
export enum ActionType {
  /**
   * @generated from enum value: ACTION_TYPE_UNKNOWN = 0;
   */
  ACTION_TYPE_UNKNOWN = 0,

  /**
   * @generated from enum value: ADD_EDIT = 1;
   */
  ADD_EDIT = 1,

  /**
   * @generated from enum value: IMPORT_SPACE = 2;
   */
  IMPORT_SPACE = 2,

  /**
   * @generated from enum value: ARCHIVE_SPACE = 3;
   */
  ARCHIVE_SPACE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ActionType)
proto3.util.setEnumType(ActionType, "ipfsv2.ActionType", [
  { no: 0, name: "ACTION_TYPE_UNKNOWN" },
  { no: 1, name: "ADD_EDIT" },
  { no: 2, name: "IMPORT_SPACE" },
  { no: 3, name: "ARCHIVE_SPACE" },
]);

/**
 * @generated from enum ipfsv2.OpType
 */
export enum OpType {
  /**
   * @generated from enum value: OP_TYPE_UNKNOWN = 0;
   */
  OP_TYPE_UNKNOWN = 0,

  /**
   * @generated from enum value: CREATE_ENTITY = 1;
   */
  CREATE_ENTITY = 1,

  /**
   * @generated from enum value: UPDATE_ENTITY = 2;
   */
  UPDATE_ENTITY = 2,

  /**
   * @generated from enum value: DELETE_ENTITY = 3;
   */
  DELETE_ENTITY = 3,

  /**
   * @generated from enum value: CREATE_RELATION = 4;
   */
  CREATE_RELATION = 4,

  /**
   * @generated from enum value: DELETE_RELATION = 5;
   */
  DELETE_RELATION = 5,

  /**
   * @generated from enum value: UPDATE_RELATION = 6;
   */
  UPDATE_RELATION = 6,

  /**
   * @generated from enum value: UNSET_PROPERTIES = 7;
   */
  UNSET_PROPERTIES = 7,

  /**
   * @generated from enum value: MOVE_ENTITY = 8;
   */
  MOVE_ENTITY = 8,

  /**
   * @generated from enum value: MERGE_ENTITIES = 9;
   */
  MERGE_ENTITIES = 9,

  /**
   * @generated from enum value: BRANCH_ENTITY = 10;
   */
  BRANCH_ENTITY = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(OpType)
proto3.util.setEnumType(OpType, "ipfsv2.OpType", [
  { no: 0, name: "OP_TYPE_UNKNOWN" },
  { no: 1, name: "CREATE_ENTITY" },
  { no: 2, name: "UPDATE_ENTITY" },
  { no: 3, name: "DELETE_ENTITY" },
  { no: 4, name: "CREATE_RELATION" },
  { no: 5, name: "DELETE_RELATION" },
  { no: 6, name: "UPDATE_RELATION" },
  { no: 7, name: "UNSET_PROPERTIES" },
  { no: 8, name: "MOVE_ENTITY" },
  { no: 9, name: "MERGE_ENTITIES" },
  { no: 10, name: "BRANCH_ENTITY" },
]);

/**
 * @generated from message ipfsv2.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: ipfsv2.ActionType type = 2;
   */
  type = ActionType.ACTION_TYPE_UNKNOWN;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ActionType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * @generated from message ipfsv2.Edit
 */
export class Edit extends Message<Edit> {
  /**
   * ------------------
   * version and type are defined on every IPFS action
   * ------------------
   *
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * Should always be 1 for ADD_EDIT
   *
   * @generated from field: ipfsv2.ActionType type = 2;
   */
  type = ActionType.ACTION_TYPE_UNKNOWN;

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * @generated from field: repeated ipfsv2.Op ops = 5;
   */
  ops: Op[] = [];

  /**
   * @generated from field: repeated string authors = 6;
   */
  authors: string[] = [];

  constructor(data?: PartialMessage<Edit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Edit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ActionType) },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ops", kind: "message", T: Op, repeated: true },
    { no: 6, name: "authors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Edit {
    return new Edit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Edit {
    return new Edit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Edit {
    return new Edit().fromJsonString(jsonString, options);
  }

  static equals(a: Edit | PlainMessage<Edit> | undefined, b: Edit | PlainMessage<Edit> | undefined): boolean {
    return proto3.util.equals(Edit, a, b);
  }
}

/**
 * @TODO: Use oneof instead of these weird optional state machines
 *
 * @generated from message ipfsv2.Op
 */
export class Op extends Message<Op> {
  /**
   * @generated from field: ipfsv2.OpType type = 1;
   */
  type = OpType.OP_TYPE_UNKNOWN;

  /**
   * *
   * Used when setting batch ops or deleting an entity
   *
   * @generated from field: optional ipfsv2.Entity entity = 2;
   */
  entity?: Entity;

  /**
   * *
   * Used when creating or deleting a relation
   *
   * @generated from field: optional ipfsv2.Relation relation = 3;
   */
  relation?: Relation;

  /**
   * @generated from field: optional ipfsv2.Property property = 4;
   */
  property?: Property;

  constructor(data?: PartialMessage<Op>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Op";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(OpType) },
    { no: 2, name: "entity", kind: "message", T: Entity, opt: true },
    { no: 3, name: "relation", kind: "message", T: Relation, opt: true },
    { no: 4, name: "property", kind: "message", T: Property, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Op {
    return new Op().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Op {
    return new Op().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Op {
    return new Op().fromJsonString(jsonString, options);
  }

  static equals(a: Op | PlainMessage<Op> | undefined, b: Op | PlainMessage<Op> | undefined): boolean {
    return proto3.util.equals(Op, a, b);
  }
}

/**
 * @generated from message ipfsv2.Property
 */
export class Property extends Message<Property> {
  /**
   * @generated from field: bytes id = 1;
   */
  id = new Uint8Array(0);

  /**
   * @generated from field: bytes type = 2;
   */
  type = new Uint8Array(0);

  /**
   * @generated from field: string name = 3;
   */
  name = "";

  constructor(data?: PartialMessage<Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "type", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Property {
    return new Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Property {
    return new Property().fromJsonString(jsonString, options);
  }

  static equals(a: Property | PlainMessage<Property> | undefined, b: Property | PlainMessage<Property> | undefined): boolean {
    return proto3.util.equals(Property, a, b);
  }
}

/**
 * @generated from message ipfsv2.Relation
 */
export class Relation extends Message<Relation> {
  /**
   * @generated from field: bytes id = 1;
   */
  id = new Uint8Array(0);

  /**
   * @generated from field: bytes type = 2;
   */
  type = new Uint8Array(0);

  /**
   * @generated from field: bytes from_entity = 3;
   */
  fromEntity = new Uint8Array(0);

  /**
   * @generated from field: optional bytes from_property = 4;
   */
  fromProperty?: Uint8Array;

  /**
   * @generated from field: bytes to_entity = 5;
   */
  toEntity = new Uint8Array(0);

  /**
   * @generated from field: optional bytes to_space = 6;
   */
  toSpace?: Uint8Array;

  /**
   * @generated from field: bytes entity = 7;
   */
  entity = new Uint8Array(0);

  /**
   * @generated from field: optional string index = 8;
   */
  index?: string;

  constructor(data?: PartialMessage<Relation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Relation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "type", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "from_entity", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "from_property", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 5, name: "to_entity", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "to_space", kind: "scalar", T: 12 /* ScalarType.BYTES */, opt: true },
    { no: 7, name: "entity", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "index", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Relation {
    return new Relation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Relation {
    return new Relation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Relation {
    return new Relation().fromJsonString(jsonString, options);
  }

  static equals(a: Relation | PlainMessage<Relation> | undefined, b: Relation | PlainMessage<Relation> | undefined): boolean {
    return proto3.util.equals(Relation, a, b);
  }
}

/**
 * @generated from message ipfsv2.Entity
 */
export class Entity extends Message<Entity> {
  /**
   * @generated from field: bytes id = 1;
   */
  id = new Uint8Array(0);

  /**
   * @generated from field: repeated ipfsv2.Value values = 2;
   */
  values: Value[] = [];

  constructor(data?: PartialMessage<Entity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Entity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "values", kind: "message", T: Value, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Entity {
    return new Entity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJsonString(jsonString, options);
  }

  static equals(a: Entity | PlainMessage<Entity> | undefined, b: Entity | PlainMessage<Entity> | undefined): boolean {
    return proto3.util.equals(Entity, a, b);
  }
}

/**
 * @generated from message ipfsv2.Value
 */
export class Value extends Message<Value> {
  /**
   * @generated from field: bytes property_id = 1;
   */
  propertyId = new Uint8Array(0);

  /**
   * If we are in an UNSET_PROPERTIES op we don't
   * need to pass the value
   *
   * @generated from field: optional string value = 2;
   */
  value?: string;

  /**
   * @generated from field: optional ipfsv2.Options options = 3;
   */
  options?: Options;

  constructor(data?: PartialMessage<Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "options", kind: "message", T: Options, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
    return new Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJsonString(jsonString, options);
  }

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean {
    return proto3.util.equals(Value, a, b);
  }
}

/**
 * @generated from message ipfsv2.Options
 */
export class Options extends Message<Options> {
  /**
   * @generated from field: optional string unit = 1;
   */
  unit?: string;

  /**
   * @generated from field: optional string format = 2;
   */
  format?: string;

  constructor(data?: PartialMessage<Options>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ipfsv2.Options";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Options {
    return new Options().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Options {
    return new Options().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Options {
    return new Options().fromJsonString(jsonString, options);
  }

  static equals(a: Options | PlainMessage<Options> | undefined, b: Options | PlainMessage<Options> | undefined): boolean {
    return proto3.util.equals(Options, a, b);
  }
}

